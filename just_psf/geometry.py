import numpy
from typing import TextIO, List, Optional
from numpy.typing import NDArray

from just_psf import logger


l_logger = logger.getChild(__name__)


class Geometry:
    def __init__(self, symbols: List[str], positions: NDArray[float]):
        assert positions.shape == (len(symbols), 3)

        self.symbols = symbols
        self.positions = positions

    def __len__(self) -> int:
        return len(self.symbols)

    def copy(self) -> 'Geometry':
        """Copy itself. Involves a copy of positions and symbols.
        """

        return Geometry(
            self.symbols.copy(),
            self.positions.copy()
        )

    @classmethod
    def from_xyz(cls, f: TextIO) -> 'Geometry':
        """Read geometry from a XYZ file
        """

        l_logger.debug('Reading geometry...')

        symbols = []
        positions = []

        n = int(f.readline())
        f.readline()

        for i in range(n):
            data = f.readline().split()
            symbols.append(data[0])
            positions.append([float(x) for x in data[1:]])

        l_logger.debug('... Got {} atom(s)'.format(n))

        return cls(symbols, numpy.array(positions))

    def to_xyz(self, title: str = '') -> str:
        """Get XYZ representation of this geometry"""

        r = '{}\n{}'.format(len(self), title)
        for i in range(len(self)):
            r += '\n{:2} {: .7f} {: .7f} {: .7f}'.format(self.symbols[i], *self.positions[i])

        return r


class PDBGeometry(Geometry):
    def __init__(
        self,
        symbols: List[str],
        positions: NDArray[float],
        seg_names: Optional[List[str]] = None,
        resi_ids: Optional[List[int]] = None,
        resi_names: Optional[list[str]] = None,
        atom_types: Optional[List[str]] = None,
    ):
        super().__init__(symbols, positions)

        assert seg_names is None or len(seg_names) == len(symbols)
        assert resi_ids is None or len(resi_ids) == len(symbols)
        assert resi_names is None or len(resi_names) == len(symbols)
        assert atom_types is None or len(atom_types) == len(symbols)

        self.seg_names = seg_names
        self.resi_ids = resi_ids
        self.resi_names = resi_names
        self.atom_types = atom_types

    @classmethod
    def from_pdb(cls, f: TextIO) -> 'PDBGeometry':
        from just_psf.parsers.pdb import PDBParser
        return PDBParser(f).pdb()

    def as_pdb(
        self,
        alt_loc: Optional[List[str]] = None,
        occupancies: Optional[List[float]] = None,
        temp_factors: Optional[List[float]] = None,
        seg_ids: Optional[List[str]] = None,
        charges: Optional[List[int]] = None,
    ) -> str:

        assert alt_loc is None or len(alt_loc) == len(self.symbols)
        assert occupancies is None or len(alt_loc) == len(self.symbols)
        assert temp_factors is None or len(temp_factors) == len(self.symbols)
        assert seg_ids is None or len(seg_ids) == len(self.symbols)
        assert charges is None or len(charges) == len(self.symbols)

        r = 'REMARK     {0}\n'.format('Generated by `{}.PDBGeometry.as_pdb()`'.format(__name__))

        # format adapted from https://docs.mdanalysis.org/stable/documentation_pages/coordinates/PDB.html
        fmt = \
            '{kw:6}{serial:5d} {atype:<4s}{alt_loc:<1s}{res_name:<4s}' \
            '{seg_name:1s}{resi_id:4d}{icode:1s}'\
            '   {pos[0]:8.3f}{pos[1]:8.3f}{pos[2]:8.3f}{occupancy:6.2f}'\
            '{temp_factor:6.2f}      {seg_id:<4s}{element:>2s}{charge:2s}\n'

        for i in range(len(self)):
            r += fmt.format(
                kw='HETATM',
                serial=i + 1,
                atype=self.atom_types[i] if self.atom_types is not None else self.symbols[i],
                alt_loc=alt_loc[i] if alt_loc is not None else '',
                res_name=self.resi_names[i] if self.resi_names is not None else 'X',
                seg_name=self.seg_names[i] if self.seg_names is not None else '',
                resi_id=self.resi_ids[i] if self.resi_ids is not None else 1,
                icode='',
                pos=self.positions[i],
                occupancy=occupancies[i] if occupancies is not None else 1.0,
                temp_factor=temp_factors[i] if temp_factors is not None else 0.0,
                seg_id=seg_ids[i] if seg_ids is not None else '',
                element=self.symbols[i],
                charge=charges[i] if charges is not None else ''
            )

        r += 'END\n'
        return r

    def to_pdb(
        self,
        f: TextIO,
        alt_loc: Optional[List[str]] = None,
        occupancies: Optional[List[float]] = None,
        temp_factors: Optional[List[float]] = None,
        seg_ids: Optional[List[str]] = None,
        charges: Optional[List[int]] = None,
    ):
        f.write(self.as_pdb(alt_loc, occupancies, temp_factors, seg_ids, charges))
